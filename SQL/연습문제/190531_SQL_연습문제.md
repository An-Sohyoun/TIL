[ 문제 1 ]

01/01/1981 부터 01/01/1982 까지 고용된사람 을

ENAME 과 HIREDATE, SAL 을 SAL 순으로 출력

```sql
SELECT ENAME, HIREDATE, SAL FROM EMP
WHERE HIREDATE > '01/01/1981' AND HIREDATE < '01/01/1982'
ORDER BY SAL;
```

[ 문제 2 ]

SAL 세금 10%, COMM 세금 5%의 연봉을 계산하여 테이블 이름을 ASAL로 하고,

연봉이 20000~30000 사이인 직원을 내림차순으로 출력

```sql
SELECT ENAME, SAL,
((SAL*12)*0.9)+((NVL(COMM,0)*12)*0.95) AS ANSAL
FROM EMP
WHERE (20000 <= (((SAL*12)*0.9)+((NVL(COMM,0)*12)*0.95))
AND 30000>=((SAL*12)*0.9)+((NVL(COMM,0)*12)*0.95))
ORDER BY ANSAL DESC ;
```

[ 문제 3 ]

1981년 입사한 사람들의 JOB은 오름차순으로, 연봉은 내림차순으로 정렬

```SQL
SELECT * FROM EMP WHERE HIREDATE >= '01/01/1981' AND HIREDATE < '01/01/1982'
ORDER BY JOB, SAL DESC;
```

[ 문제 4 ]

EMP 테이블에서 COMM이 NULL인 것 중 연봉계산(세금 30%)을 하고 

이름 가운데에 'I'가 들어가는 사람들을 연봉의 내림차순으로 정렬

```sql
SELECT * FROM EMP 
WHERE COMM IS NULL
AND ENAME LIKE '%I%'
ORDER BY ((SAL*12)*0.7) DESC;
```

[ 문제 5 ]

SAL이 2000~3000인 사람들 중 JOB이나 ENAME에 'S'가 포함된 사람

```SQL
SELECT * FROM EMP WHERE SAL>=2000 AND SAL<=3000
AND (JOB LIKE '%S%' OR ENAME LIKE '%S%');
```

[ 문제 6 ]

위와 같은 표가 나오도록 SQL을 작성

단, 연봉(ANNSAL)은 SAL의 세금은 22%, COMM의 세금은 12%로 계산

```SQL
SELECT JOB,ENAME,SAL, 
((SAL*12)*0.78) + ((NVL(COMM,0)*12)*0.88) AS ANNSAL
FROM EMP
WHERE 25000 <= ((SAL*12)*0.78 + ((NVL(COMM,0)*12)*0.88))
ORDER BY JOB, ENAME;
```

[ 문제7 ]

ENAME , 근무일수(WD) , JOB , SAL , NCOMM (바뀐 COMM)을 출력하시오.

근무일수(WD)는 소숫점을 제거하여 출력 / 근무일수가 13800 이상 된 사람의 COMM 200 추가

JOB은 앞 세자리만 출력

```SQL
SELECT ENAME, 
ROUND(SYSDATE-HIREDATE,0) AS WD,
SUBSTR(JOB,1,3) AS JOB,
SAL,
(NVL(COMM,0)+200) AS NCOMM
FROM EMP WHERE 13800<= SYSDATE-HIREDATE;
```

[ 문제 8 ]

NAME , ASAL(연봉) , EARN(월급 + COMM) , SAL , COMM을 출력하시오.

ENAME 첫글자만 대문자 / 월급이 3000이상이면 세금 30%, 이하면 20% 로 연봉 계산

월급과 COMM은 내림차순 정렬

```sql
SELECT 
REPLACE(ENAME,
SUBSTR(ENAME,2,LENGTH(ENAME)),
LOWER(SUBSTR(ENAME,2,LENGTH(ENAME)))) AS NAME,

CASE WHEN 3000<=SAL
     THEN (SAL*12)*0.7
     ELSE (SAL*12)*0.8
END AS ASAL,

(NVL(COMM,0)+SAL) AS EARN,
SAL,COMM
FROM EMP 
ORDER BY EARN DESC, COMM DESC
```

[ 문제 9 ]

연봉(ANNSAL)은 내림차순 으로 정렬  / ENAME은 오름차순

연봉(ANNSAL) 계산 : SAL의 세금 22%, COMM의 세금 12%

실제 받는 연봉(REAL ANNSAL) 계산 → 100단위는 버림

연봉 분류 : 

연봉(ANNSAL)이 30000 이상이면 '부자', 20000이상 30000미만이면 '중상층', 20000미만이면 '평민'

```sql
SELECT ENAME,
((SAL*12)*0.78+(NVL(COMM,0)*12)*0.88) AS ANNSAL,
TRUNC(((SAL*12)*0.78+(NVL(COMM,0)*12)*0.88),-2) AS REALANNSAL,

CASE WHEN 30000 <= ((SAL*12)*0.78+(NVL(COMM,0)*12)*0.88)
     THEN '부자'
     WHEN 20000 <=((SAL*12)*0.78+(NVL(COMM,0)*12)*0.88)
          AND ((SAL*12)*0.78+(NVL(COMM,0)*12)*0.88) <30000
     THEN '중산층'
     ELSE '평민'
END AS "연봉 분류"

FROM EMP
ORDER BY ANNSAL DESC, ENAME;
```

[ 문제 10 ]

ENAME, JOB, HIREDATE, SYSDATE와 ASAL(연봉)

REALASAL(ASAL>50000이면 세금 50%, 50000>ASAL>35000이면 세금 30%, 나머지는 세금 20%)

TOTALMONEY = (SAL+COMM)*지금까지 일한 MONTH의 수(세금은 없고 소수점은 반올림)

직업을 오름차순으로 정렬한 후, TOTALMONEY는 내림차순으로 정렬

```sql
SELECT ENAME, JOB, HIREDATE, SYSDATE,
(SAL*12) + (NVL(COMM,0)*12) AS ASAL,

CASE WHEN 50000<((SAL*12) + (NVL(COMM,0)*12))
     THEN ((SAL*12) + (NVL(COMM,0)*12))*0.5
     WHEN 35000<((SAL*12) + (NVL(COMM,0)*12)) 
          AND ((SAL*12) + (NVL(COMM,0)*12))<50000
     THEN ((SAL*12) + (NVL(COMM,0)*12))*0.7
     ELSE ((SAL*12) + (NVL(COMM,0)*12))*0.8
END AS REALASAL,

ROUND((SAL+NVL(COMM,0))*MONTHS_BETWEEN(SYSDATE,HIREDATE),0) AS TOTALMONEY
FROM EMP
ORDER BY JOB, TOTALMONEY DESC;
```

[ 문제 11 ]

COMM이 없고 

이름에 'I'나 'M'이 들어가는 사람 이름의 첫글자는 대문자로 나머지는 소문자로하여 

DEPTNO, NAME, JOB, HIREDATE, COMM을 출력하시오. (→DEPTNO 내림차순으로 정렬)

```sql
SELECT DEPTNO,
REPLACE(ENAME,
SUBSTR(ENAME,2,LENGTH(ENAME)),
LOWER(SUBSTR(ENAME,2,LENGTH(ENAME)))) AS NAME,
 
JOB, HIREDATE, COMM

FROM EMP WHERE COMM IS NULL 
AND (ENAME LIKE '%I%' OR ENAME LIKE '%M%')
ORDER BY DEPTNO DESC;
```

[ 문제 12 ]

첫 글자만 대문자로 바꾼 'RENAME'을 오름차순으로 정렬

```sql
SELECT 
REPLACE(ENAME,
SUBSTR(ENAME,2,LENGTH(ENAME)),
LOWER(SUBSTR(ENAME,2,LENGTH(ENAME)))) AS RESULT
 
FROM EMP 
ORDER BY RESULT;
```

[ 문제 13 ]

EMP에서 (현재날짜에서 HIREDATE를 뺀)DAYS와 직급 COLUMN을 새롭게 만듦

이후 CLERK만 뽑아 DAYS 내림차순으로 출력

직급 기준 : 부장: DAYS>=14000 | 과장: 14000>DAYS >=13500 | 직원: DAYS<13500

```sql
SELECT ENAME, JOB, HIREDATE,
ROUND(SYSDATE-HIREDATE,0) AS DAYS,

CASE WHEN (SYSDATE-HIREDATE)>=14000
     THEN '부장'
     WHEN 13500<=(SYSDATE-HIREDATE) AND (SYSDATE-HIREDATE)<14000
     THEN '과장'
     ELSE '직원'
END AS "직급"

FROM EMP WHERE JOB = 'CLERK'
ORDER BY DAYS DESC;
```

[ 문제 14 ]

이름과 직업 앞 세자리를 잘라 NICKNAME과 JOB COLUMN을 만듦

HIREDATE의 12월과 11월 입사 직원만 뽑아, SAL 오름차순으로 출력

```SQL
SELECT 
SUBSTR(ENAME,1,3) AS NICKNAME,
SUBSTR(JOB,1,3) AS JOB,
HIREDATE, SAL,
TO_CHAR(HIREDATE,'MM') AS MONTH
FROM EMP WHERE TO_CHAR(HIREDATE,'MM') IN (11,12)
ORDER BY SAL;
```

[ 문제 15 ]

HIREDATE FORMAT을 2019-05-21 방식으로 바꾸고, 

JOB의 첫글자를 제외한 나머지는 모두 소문자로 바꾸고

JOB이 ER이나 ST로 끝날 때 출력 → SAL 기준으로 오름차순 정렬

```sql
SELECT ENAME,
REPLACE(JOB, 
SUBSTR(JOB,2,LENGTH(JOB)), 
LOWER(SUBSTR(JOB,2,LENGTH(JOB)))) AS "JOB_L",
SAL,
TO_CHAR(HIREDATE,'YYYY-MM-DD') AS HD
FROM EMP WHERE JOB LIKE '%ER' OR JOB LIKE '%ST'
ORDER BY SAL;

```

[ 문제 16 ]

COMM이 NULL 일 때 0이 나오는 raw의 HIREDATE를 뽑아서 HIREDATE를 오름차순으로 정렬

NULL이 나오는 애들의 고용날짜를 내림차순으로 정렬

SYSDATE-HIREDATE 를 기준으로 몇 일 이상이면  부장,차장,과장,대리,사원으로 출력

```sql
SELECT ENAME, JOB, SAL,HIREDATE,
TRUNC(SYSDATE-HIREDATE,0) AS "근무일",

CASE WHEN 14000<= (SYSDATE-HIREDATE)
     THEN '부장'
     WHEN 13900<= (SYSDATE-HIREDATE) AND (SYSDATE-HIREDATE)<14000
     THEN '차장'
     WHEN 13700<= (SYSDATE-HIREDATE) AND (SYSDATE-HIREDATE)<13900
     THEN '과장'
     WHEN 13600<= (SYSDATE-HIREDATE) AND (SYSDATE-HIREDATE)<13700 
     THEN '대리'
     ELSE '사원'
END AS "RANK"
FROM EMP WHERE COMM IS NULL
ORDER BY 근무일 DESC;
```

[ 문제 17 ]

근무일수(월별)를 계산하여 소수점 이하는 버림 → 근무일수에 따라서 보너스를 지급함

450일 이상 = 월급의 50%, 특별 보너스로 입사일이 5월이면 월급의 50% 보너스 추가 지급

440일 이상 = 월급의 20%, 그 아래는 0%

근무일수가 높은 순서대로 정렬

```sql
SELECT ENAME,
TRUNC(MONTHS_BETWEEN(SYSDATE,HIREDATE),0) AS WORK,
SAL,

CASE WHEN 450<= MONTHS_BETWEEN(SYSDATE,HIREDATE) AND TO_CHAR(HIREDATE,'MM')=05
     THEN SAL*1.0
     WHEN 450<= MONTHS_BETWEEN(SYSDATE,HIREDATE)
     THEN SAL*0.5
     WHEN 440<= MONTHS_BETWEEN(SYSDATE,HIREDATE) 
          AND MONTHS_BETWEEN(SYSDATE,HIREDATE)<450
     THEN SAL*0.2
     ELSE SAL*0
END AS BONUS

FROM EMP
ORDER BY WORK DESC;
```

[ 문제 18 ]

위와 같은 테이블을 출력하시오. EMP 테이블 활용

고용달을 기준으로 내림차순 정렬한 후, 고용달 수가 같으면 이름 오름차순으로 정렬

```sql
SELECT ENAME,HIREDATE
FROM EMP
ORDER BY TO_CHAR(HIREDATE,'MM') DESC, ENAME;
```

